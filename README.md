# SS18-Semesterarbeit-CPP2-Roland
Semesterarbeit von Kim Roland im BM3-Modul Softwaretechnologie, Seminar "Objektorientierte Programmierung: C++-Programmieren-2"

## Dokumentation
Im Rahmen dieser Semesterarbeit wurden die Stufen IV, III und II der Aufgabenstellung erfolgreich realisiert.

### Projekt herunterladen
- Projekt-Masterversion aus diesem Repository als ZIP-Ordner herunterladen und entpacken
- .pro-Datei des Projektes (*SS18-Semesterarbeit-CPP2-Roland.pro*) mit QT √∂ffnen und konfigurieren
- Ausf√ºhren (Kompilieren erfolgreich getestet mit folgenden Programmversionen: Qt 5.9.2 (Clang 7.0 (Apple), 64 bit) und Qt Creator 4.4.1)
- Spielwidget √∂ffnet sich

### Spielfunktionen

#### Spiel starten
Durch Anklicken des **Start**-Buttons in der oben linken Ecke des Spielfensters wird das Spiel gestartet. Der Button wechselt die Beschriftung zu **Pause**. √úber erneutes Anklicken des Buttons kann das Spiel also pausiert werden.

#### Spielen
Der Spieler (schraffiertes Rechteck) kann sich mit den Tastatur-Pfeiltasten ‚¨ÖÔ∏è ‚û°Ô∏è am unteren Rand des Spielfeldes nach links und rechts bewegen und muss den herunterfallenden Elementen (Gegnern) ausweichen. Wird der Spieler von einem Gegnerelement getroffen (die beiden Spielobjekte ber√ºhren sich), verliert der Spieler ein Leben (‚ö™Ô∏èüî¥üî¥: Lebensanzeige in der oberen rechten Spielfeldecke) und das Spiel friert kurz ein. Nach dieser kurzen Spielpause startet das Spiel wieder und l√§uft weiter. Wenn der Spieler getroffen wurde, wird er abgeschw√§cht dargestellt, je nach Anzahl der noch vorhandenen Leben. Insgesamt gibt es drei verschiedene optische Darstellungen des Spielers (bei vollen Leben, bei Verlust eines Lebens, bei nur noch einem vorhandenen Leben). Au√üerdem ist der Spieler nach der Kollision mit einem Gegnerelement f√ºr ein paar Sekunden unverwundbar (zugunsten des besseren Spielflusses, um eine direkt darauffolgende Kollision mit einem anderen Gegnerelement zu vermeiden). Danach kann er wieder von weiteren Gegnerelementen getroffen werden.
Verlorene Leben k√∂nnen durch die Ber√ºhrung von herunterfallenden roten Kreis-Elementen üî¥, die optisch dem Aussehen der Lebensanzeige entsprechen, regeneriert werden. Bei der Kollision mit dieser Art von Elementen wird das Spiel ebenfalls kurz eingefroren, aber ein Leben hinzugef√ºgt statt abgezogen. Die maximale Anzahl an Leben entspricht 3, bei voller Lebensanzahl k√∂nnen die Leben nicht weiter addiert werden.

#### Speichern und Laden
Die Buttons **Speichern** und **Laden** erm√∂glichen es dem Spieler, den aktuellen Spielstand f√ºr das Weiterspielen zu einem sp√§teren Zeitpunkt zu speichern oder vor dem Spielstart einen alten gespeicherten Spielstand wieder herzustellen. Um diese Funktionen nutzen zu k√∂nnen, darf das Spiel nicht laufen, sondern muss pausiert sein. 
Im Rahmen der Speicherung lassen sich alle relevanten Spielinformationen speichern: die aktuelle Position des Spielers sowie seine aktuelle optische Darstellung, die Anzahl seiner vorhandenen Leben, die bisher erreichte Punktzahl sowie die Anzahl, Position und der jeweilige Element-Typ (regelt Form, Farbe und Fallgeschwindkeit) der sich momentan im Spielfeld befindenden Gegnerelemente.
Ein alter Spielstand kann sowohl direkt nach dem Start der Spielanwendung als nach dem Pausieren eines bereits gelaufenen Spiels geladen werden. Im Rahmen des Ladens werden die beschriebenen Spielinformationen vollst√§ndig wiederhergestellt und der Spieler kann durch Anklicken des **Start**-Buttons nach dem Laden genau mit diesem letzten Spielstand weiterspielen.

#### Spielende
Hat der Spieler alle drei Leben verloren, wird das Spielende durch die Anzeige von "Game Over" und der in dem Spieldurchgang erreichten Punktzahl angezeigt. Danach werden die Spielinformationen zur√ºckgesetzt (optische Spielerdarstellung, Lebensanzahl und Punktzahl), die aktuellen Gegner entfernt/neu erzeugt und das Spiel startet erneut. Alternativ kann die gesamte Spielanwendung auch √ºber den Button **Ende** am unteren linken Spielfeldrand beendet werden.

## Programm-Erl√§uterungen: Wichtige Klassen und Methoden
1. Die `class gameWidget` erstellt das Spielfenster und definiert dessen Aufbau, die Funktions-Buttons (**Start/Pause**, **Speichern**, **Laden**, **Ende**), deren verkn√ºpfte Methoden und intialisiert den Renderbereich f√ºr das Zeichenfeld, in dem das Spiel stattfindet, als `myGameArea` auf Basis der `class gameArea`.
  - `gameWidget::startStopGame()`: regelt aktiven und inaktiven Zustand des Spiels, ver√§ndert die Beschriftung des Button, setzt aktiven und inaktiven Zustand der Buttons **Speichern** und **Laden** anhand des Spielstatus.
  - `gameWidget::saveGame()`: l√∂st Erzeugung der Datei f√ºr die Speicherung aus, ruft Methode `gameArea::serialize()`auf.
  - `gameWidget::loadGame()`: l√∂st Lesen der Datei f√ºr das Laden aus, ruft Methode `gameArea::deserialize()`auf.

2. Die `class player` ist f√ºr die Definition des Spielerrechtecks zust√§ndig und beinhaltet die n√∂tigen Methoden zur Erzeugung und Bewegung des Spieleravatars:
  - Setter- und Getter-Methoden f√ºr die Positionsfestlegung (`playerX`, `playerY`), Abmessungen (`playerWidth`, `playerHeight`) des Spielers, f√ºr die Schrittweite der Spielerbewegung (`playerMove`) sowie f√ºr die ver√§nderte optische Darstellung (Farbe und F√ºllmuster) des Spielers bei Lebensverlust (`playerColor`, `playerPattern`). F√ºr letzteres au√üerdem Set- und Get-Methode f√ºr Verwaltung der ver√§nderten Spielerdarstellung (`playerStyle`), anhand von drei numerischen Werten (0,1,2)
    - `playerStyle==0`: 'gesunde' Darstellung des Spielers bei vollen Leben, schraffiertes Quadrat
    - `playerStyle==1`: abgeschw√§chte Darstellung des Spielers Stufe 1: mittelblau und gepunktet
    - `playerStyle==2`: abgeschw√§chte Darstellung des Spielers Stufe 2: sehr helles blau, leerer Rahmen
  - `paintEvent` und `keyPressEvent` zur Zeichnung und Bewegungsf√§higkeit des Spielers in der `gameArea`
  - Die `class movement` dient als Hilfsklasse f√ºr die `class player`, definiert die Bewegungen des Spielers in einem enum, um sie sp√§ter in der `player::movePlayer()`-Methode verwenden zu k√∂nnen und initalisiert diese Methode dynamisch, mit dem enum und einem Ausgangswert

3. Die `class element` ist f√ºr die Gegnerelemente (enemies) im Spiel zust√§ndig:
  - Die Variable `elementType` √ºbernimmt dabei eine zentrale Rolle, da √ºber sie ein numerischer Wert von 0-5 gespeichert wird, der jeweils f√ºr ein bestimmtes Gegenerelement steht. Mit diesen Werten werden die spezifischen Elementeigenschaften verkn√ºpft.
  - Die Methode `element::newElement` sorgt f√ºr die zuf√§llige Auswahl neuer Gegnerlemente, indem sie mit `rand()` zuf√§llige X-Positionen und zuf√§llige Werte des `elementType` generiert und mit diesen zuf√§lligen Werten die Methode `element::setElement` aufruft. Au√üerdem definiert sie, dass das letzte Element der Gegnerliste (der rote Kreis, der Leben wieder hinzuf√ºgt) mit zehnprozentiger Wahrscheinlichkeit generiert werden soll.
  - Die Methode `element::setElement` enth√§lt Vektoren zur Speicherung der m√∂glichen Elementeigenschaften in Bezug auf die Gr√∂√üe/Abmessungen, die innere Farbe, die Farbe und Breite der Au√üenlinie, das F√ºllmuster und die Fallgeschwindigkeit eines Elements. Die Speicherung in den Vektoren erfolgt nach einer festen Reihenfolge, um Eigenschaften anhand ihrer Position im Vektor einem `elementType` zuordnen zu k√∂nnen. So werden die Elementeigenschaften jeweils in nur einer Hilfsvariable pro Eigenschaft (`rect`,`color`,`pattern`,`pen`,`penWidth`,`yMovement`) gespeichert, die ver√§nderbar sind und anhand des (zuf√§lligen) `elementType` bei der Erzeugung eines Elements festgelegt werden.
  - Die Methode `element::moveElement` erzeugt das Fallen der Gegnerelemente, also ihre Bewegung im Spielfeld von oben nach unten, √ºber den Aufruf der `translate()`-Methode der Klasse `QRectF` mit dem elementspezifischen Vektorenwert `yMovement`.

4. Die `class gameArea` definiert das Zeichenfeld des Spiels, in dem sich der Spieler und die Gegnerelemente bewegen. Sie ist zust√§ndig f√ºr: den Spiel-Timer und die Punkteanzeige, die Aktualisierung, das Pausieren und das Ende des Spiels, f√ºr das Zeichnen der Gegner und der Leben, f√ºr die Kollisionsabfrage von Spieler und Gegnern sowie f√ºr das Ausl√∂sen der ver√§nderten Darstellung des Spielers bei seiner Kollision mit einem Gegnerelement. Kurz gesagt regelt die Klasse alles, was innerhalb des Spiels passiert.
  - Im Konstruktor der `gameArea` wird das Spiel mit seinem Anfangszustand initalisiert. Auf Basis der Positions- und Layout-Definitionen der `class player` wird das Spielerrechteck im Zeichenfeld erzeugt. Die Methode `gameArea::setRunning` sowie ihre `bool`-Variable `running` werden auf `false` gesetzt, damit sich das Spielfenster im inaktiven Zustand des Spiels √∂ffnet. Desweiteren werden die Spielpunkte, die Leben und die f√ºr die verschiedenen Pause- und Endzust√§nde `unverwundbar`, `getroffen` und `gameOver` zust√§ndigen Variablen und Timer mit Ausgangswerten initialisiert. Au√üerdem wird hier der Spieltimer hinzugef√ºgt und definiert sowie der Vektor `std::vector<element*> enemies`, √ºber den die Gegnerelemente hinzugef√ºgt werden, mit neuen zuf√§lligen Elementen bef√ºllt.
  - Die Methode `gameArea::updateGame` regelt die Aktualisierung der Spielzust√§nde und des Punktecounters. Sie wurde im Konstruktor mit dem Timer verkn√ºpft. In ihr ist festgelegt, was w√§hrend der verschiedenen Spielphasen geschehen soll. W√§hrend das Spiel l√§uft, soll die Punktzahl konstant erh√∂ht werden. Au√üerdem werden hier die Zeitintervalle nach der Kollision mit einem Gegner und f√ºr die tempor√§re GameOver-Anzeige gestartet. Diese seperaten Zustands-Timer werden solange erh√∂ht, bis sie den Wert des zugeh√∂rigen Timeouts (in `gameArea.h` konstant festgelegt) erreicht haben. Es wird definiert, was nach dem Timeout geschehen soll: 
    - Wenn der Spieler getroffen wurde, soll der Timer f√ºr das Timeout des `getroffen`-Zustandes gestartet werden, der Spieler `unverwundbar` gemacht (und damit auch der unverwundbar-Timer gestartet werden). Nach Ende des Timeouts wird das Spiel wieder in den aktiven Zustand versetzt, l√§uft also weiter. 
    - Wenn der Spieler `unverwundbar` ist, soll ebenfalls ein Timer f√ºr die Zeit der Unverwundbarkeit gestartet werden. So wird verhindert, dass der Spieler nicht direkt nach Ende des `getroffen`-Timeouts mit dem n√§chsten, eventuell direkt √ºber ihm liegenden, aber eingefrorenen Gegner kollidiert, ohne die Chance zu haben, auszuweichen. Nach Ende des `unverwundbar`-Zustands kann der Spieler wieder von Gegnern getroffen werden. 
    - `gameOver`

  - Die Methode `gameArea::drawLives()`
  - Die Methode `gameArea::changePlayerStyle()`
  - Die Methode `gameArea::drawEnemies()`
  - Das `paintEvent` der `gameArea` l√∂st die `drawLives()`- und `drawEnemies()`-Methoden aus. 
  - Die Methode `gameArea::gameIsOver()`
  - Die Methode `gameArea::setRunning()`
  - Die Methode `gameArea::serialize()`
  - Die Methode `gameArea::deserialize()`

