# SS18-Semesterarbeit-CPP2-Roland
Semesterarbeit von Kim Roland im BM3-Modul Softwaretechnologie, Seminar "Objektorientierte Programmierung: C++-Programmieren-2"

# Dokumentation
Im Rahmen dieser Semesterarbeit wurden die Stufen IV, III und II der Aufgabenstellung erfolgreich realisiert.

### Projekt herunterladen
- Projekt-Masterversion aus diesem Repository als ZIP-Ordner herunterladen und entpacken
- .pro-Datei des Projektes (*SS18-Semesterarbeit-CPP2-Roland.pro*) mit QT √∂ffnen und konfigurieren
- Ausf√ºhren (Kompilieren erfolgreich getestet mit folgenden Programmversionen: *Qt 5.9.2 (Clang 7.0 (Apple), 64 bit)* und *Qt Creator 4.4.1*)
- Spielwidget √∂ffnet sich

### Spielfunktionen

#### Spiel starten
Durch Anklicken des **Start**-Buttons in der oben linken Ecke des Spielfensters wird das Spiel gestartet. Der Button wechselt die Beschriftung zu **Pause**. √úber erneutes Anklicken des Buttons kann das Spiel pausiert werden.

#### Spielen
Der Spieler (schraffiertes Rechteck) kann sich mit den Tastatur-Pfeiltasten ‚¨ÖÔ∏è ‚û°Ô∏è am unteren Rand des Spielfeldes nach links und rechts bewegen und muss den herunterfallenden Elementen (Gegnern) ausweichen. Wird der Spieler von einem Gegnerelement getroffen (die beiden Spielobjekte ber√ºhren sich), verliert der Spieler ein Leben (‚ö™Ô∏èüî¥üî¥: Lebensanzeige in der oberen rechten Spielfeldecke) und das Spiel friert kurz ein. Nach dieser kurzen Spielpause startet das Spiel wieder und l√§uft weiter. Wenn der Spieler getroffen wurde, wird er abgeschw√§cht dargestellt, je nach Anzahl der noch vorhandenen Leben. Insgesamt gibt es drei verschiedene optische Darstellungen des Spielers (bei vollen Leben, bei Verlust eines Lebens, bei nur noch einem vorhandenen Leben). Au√üerdem ist der Spieler nach der Kollision mit einem Gegnerelement f√ºr ein paar Sekunden unverwundbar (zugunsten des besseren Spielflusses, um eine direkt darauffolgende Kollision mit einem anderen Gegnerelement zu vermeiden). Danach kann er wieder von weiteren Gegnerelementen getroffen werden.
Verlorene Leben k√∂nnen durch die Ber√ºhrung von herunterfallenden roten Kreis-Elementen üî¥, die optisch dem Aussehen der Lebensanzeige entsprechen, regeneriert werden. Bei der Kollision mit dieser Art von Elementen wird das Spiel ebenfalls kurz eingefroren, aber ein Leben hinzugef√ºgt statt abgezogen. Die maximale Anzahl an Leben entspricht 3, bei voller Lebensanzahl k√∂nnen die Leben nicht weiter addiert werden.

#### Speichern und Laden
Die Buttons **Speichern** und **Laden** erm√∂glichen es dem Spieler, den aktuellen Spielstand f√ºr das Weiterspielen zu einem sp√§teren Zeitpunkt zu speichern oder einen alten gespeicherten Spielstand wieder herzustellen. Um diese Funktionen nutzen zu k√∂nnen, darf das Spiel nicht laufen, sondern muss pausiert sein. 
Im Rahmen der Speicherung lassen sich alle relevanten Spielinformationen speichern: die aktuelle Position des Spielers sowie seine aktuelle optische Darstellung, die Anzahl seiner vorhandenen Leben, die bisher erreichte Punktzahl sowie die Anzahl, Position und der jeweilige Element-Typ (regelt Form, Farbe und Fallgeschwindkeit) der sich momentan im Spielfeld befindenden Gegnerelemente.
Ein alter Spielstand kann sowohl direkt nach dem Start der Spielanwendung als auch nach dem Pausieren eines bereits gelaufenen Spiels geladen werden. Im Rahmen des Ladens werden die beschriebenen Spielinformationen vollst√§ndig wiederhergestellt und der Spieler kann durch Anklicken des **Start**-Buttons nach dem Laden genau mit diesem letzten Spielstand weiterspielen.

#### Spielende
Hat der Spieler alle drei Leben verloren, wird das Spielende durch die Anzeige von "Game Over" und der in dem Spieldurchgang erreichten Punktzahl angezeigt. Die Spielinformationen werden zur√ºckgesetzt (optische Spielerdarstellung, Lebensanzahl und Punktzahl), die aktuellen Gegner entfernt/neu erzeugt und das Spiel startet erneut. Alternativ kann die gesamte Spielanwendung auch √ºber den Button **Ende** am unteren linken Spielfeldrand beendet werden.

## Programm-Erl√§uterungen: Wichtige Klassen und Methoden
1. Die `class gameWidget` erstellt das Spielfenster und definiert dessen Aufbau, die Funktions-Buttons (**Start/Pause**, **Speichern**, **Laden**, **Ende**), deren verkn√ºpfte Methoden und intialisiert den Renderbereich f√ºr das Zeichenfeld, in dem das Spiel stattfindet, als `myGameArea` auf Basis der `class gameArea`.
    - `gameWidget::startStopGame()`: regelt aktiven und inaktiven Zustand des Spiels, ver√§ndert die Beschriftung des Start/Pause-Button, setzt aktiven und inaktiven Zustand der Buttons **Speichern** und **Laden** anhand des Spielstatus.
    - `gameWidget::saveGame()`: l√∂st Erzeugung der Datei f√ºr die Speicherung aus, ruft Methode `gameArea::serialize()`auf.
    - `gameWidget::loadGame()`: l√∂st Lesen der Datei f√ºr das Laden aus, ruft Methode `gameArea::deserialize()`auf.

2. Die `class player` ist f√ºr die Definition des Spielerrechtecks zust√§ndig und beinhaltet die n√∂tigen Methoden zur Erzeugung und Bewegung des Spieleravatars:
    - Setter- und Getter-Methoden f√ºr die Positionsfestlegung (`playerX`, `playerY`) und Abmessungen (`playerWidth`, `playerHeight`) des Spielers, f√ºr die Schrittweite der Spielerbewegung (`playerMove`) sowie f√ºr die ver√§nderte optische Darstellung (Farbe und F√ºllmuster) des Spielers bei Lebensverlust (`playerColor`, `playerPattern`). F√ºr letzteres enth√§lt die Klasse au√üerdem eine Set- und Get-Methode zur Verwaltung der ver√§nderten Spielerdarstellung (`playerStyle`), anhand von drei numerischen Werten (0,1,2)
      - `playerStyle==0`: 'gesunde' Darstellung des Spielers bei vollen Leben, schraffiertes Quadrat
      - `playerStyle==1`: abgeschw√§chte Darstellung des Spielers Stufe 1: mittelblau und gepunktet
      - `playerStyle==2`: abgeschw√§chte Darstellung des Spielers Stufe 2: sehr helles blau, leerer Rahmen
    - `paintEvent` und `keyPressEvent` zur Zeichnung und Bewegungsf√§higkeit des Spielers in der `gameArea`
    - Die `class movement` dient als Hilfsklasse f√ºr die `class player`, definiert die Bewegungen des Spielers in einem enum, um sie sp√§ter in der `player::movePlayer()`-Methode verwenden zu k√∂nnen und initalisiert diese Methode dynamisch, mit dem enum und einem Ausgangswert

3. Die `class element` ist f√ºr die Gegnerelemente (enemies) im Spiel zust√§ndig:
    - Die Variable `elementType` √ºbernimmt dabei eine zentrale Rolle, da √ºber sie ein numerischer Wert von 0-5 gespeichert wird, der jeweils f√ºr ein bestimmtes Gegenerelement steht. Mit diesen Werten werden die spezifischen Elementeigenschaften verkn√ºpft.
    - Die Methode `element::newElement` sorgt f√ºr die zuf√§llige Auswahl neuer Gegnerlemente, indem sie mit `rand()` zuf√§llige X-Positionen und zuf√§llige Werte des `elementType` generiert und mit diesen zuf√§lligen Werten die Methode `element::setElement` aufruft. Au√üerdem definiert sie, dass das letzte Element der Gegnerliste (der rote Kreis, der Leben wieder hinzuf√ºgt) mit zehnprozentiger Wahrscheinlichkeit generiert werden soll.
    - Die Methode `element::setElement` enth√§lt Vektoren zur Speicherung der m√∂glichen Elementeigenschaften in Bezug auf die Gr√∂√üe/Abmessungen, die innere Farbe, die Farbe und Breite der Au√üenlinie, das F√ºllmuster und die Fallgeschwindigkeit eines Elements. Die Speicherung in den Vektoren erfolgt nach einer festen Reihenfolge, um Eigenschaften anhand ihrer Position im Vektor einem `elementType` zuordnen zu k√∂nnen. So werden die Elementeigenschaften jeweils in nur einer Hilfsvariable pro Eigenschaft (`rect`,`color`,`pattern`,`pen`,`penWidth`,`yMovement`) gespeichert, die ver√§nderbar sind und anhand des (zuf√§lligen) `elementType` bei der Erzeugung eines Elements festgelegt werden.
    - Die Methode `element::moveElement` erzeugt das Fallen der Gegnerelemente, also ihre Bewegung im Spielfeld von oben nach unten, √ºber den Aufruf der `translate()`-Methode der Klasse `QRectF` mit dem elementspezifischen Vektorenwert `yMovement`.

4. Die `class gameArea` definiert das Zeichenfeld des Spiels, in dem sich der Spieler und die Gegnerelemente bewegen. Sie ist zust√§ndig f√ºr: den Spiel-Timer und die Punkteanzeige, die Aktualisierung, das Pausieren und das Ende des Spiels, f√ºr das Zeichnen der Gegner und der Leben, f√ºr die Kollisionsabfrage von Spieler und Gegnern sowie f√ºr das Ausl√∂sen der ver√§nderten Darstellung des Spielers bei seiner Kollision mit einem Gegnerelement. Kurz gesagt regelt die Klasse alles, was innerhalb des Spiels passiert.
    - Im Konstruktor der `gameArea` wird das Spiel mit seinem Anfangszustand initalisiert. Auf Basis der Positions- und Layout-Definitionen der `class player` wird das Spielerrechteck im Zeichenfeld erzeugt. Die Methode `gameArea::setRunning` sowie ihre `bool`-Variable `running` werden auf `false` gesetzt, damit sich das Spielfenster im inaktiven Zustand des Spiels √∂ffnet. Desweiteren werden die Spielpunkte, die Leben und die f√ºr die verschiedenen Pause- und Endzust√§nde `unverwundbar`, `getroffen` und `gameOver` zust√§ndigen Variablen und Timer mit Ausgangswerten initialisiert. Au√üerdem wird hier der Spieltimer hinzugef√ºgt und definiert sowie der Vektor `std::vector<element*> enemies`, √ºber den die Gegnerelemente hinzugef√ºgt werden, mit neuen zuf√§lligen Elementen bef√ºllt.
    - Die Methode `gameArea::updateGame` regelt die Aktualisierung der Spielzust√§nde und des Punktecounters. Sie wurde im Konstruktor mit dem Timer verkn√ºpft. In ihr ist festgelegt, was w√§hrend der verschiedenen Spielphasen geschehen soll. W√§hrend das Spiel l√§uft, soll die Punktzahl konstant erh√∂ht werden. Au√üerdem werden hier die Zeitintervalle nach der Kollision mit einem Gegner und f√ºr die tempor√§re GameOver-Anzeige gestartet. Diese seperaten Zustands-Timer werden solange erh√∂ht, bis sie den Wert des zugeh√∂rigen Timeouts (in `gameArea.h` konstant festgelegt) erreicht haben. Es wird definiert, was nach dem Timeout geschehen soll: 
    - Wenn der Spieler getroffen wurde, soll der Timer f√ºr das Timeout des `getroffen`-Zustandes gestartet werden, der Spieler `unverwundbar` gemacht (und damit auch der unverwundbar-Timer gestartet werden). Nach Ende des Timeouts wird das Spiel wieder in den aktiven Zustand versetzt, l√§uft also weiter. 
    - Wenn der Spieler `unverwundbar` ist, soll ebenfalls ein Timer f√ºr die Zeit der Unverwundbarkeit gestartet werden. So wird verhindert, dass der Spieler nicht direkt nach Ende des `getroffen`-Timeouts mit dem n√§chsten, eventuell direkt √ºber ihm liegenden, aber eingefrorenen Gegner kollidiert, ohne die Chance zu haben, auszuweichen. Nach Ende des `unverwundbar`-Zustands kann der Spieler wieder von Gegnern getroffen werden. 
    - Wenn der Spieler alle drei Leben verloren hat, wird durch den Aufruf der `gameArea::gameIsOver`-Methode die bool-Variable `gameOver`auf true gesetzt (und `getroffen` auf `false`, um nicht den `getroffenTimer`auszul√∂sen). Dadurch friert das Spiel ein und der gameOver-Timer wird gestartet. Nach dem Ende des gameOver-Timeouts wird die Game Over-Anzeige wieder vom Spielfeld entfernt sowie die Leben und die Spielerdarstellung zur√ºckgesetzt.
    - Das `gameArea::paintEvent` l√∂st die `drawLives()`- und `drawEnemies()`-Methoden aus und √ºbergibt diesen den im paintEvent erzeugten `painter`.
    - Die Methode `gameArea::drawLives()` ist f√ºr die Lebensanzeige zust√§ndig. Ihr wird aus der Paint-Methode der painter √ºbergeben und durch ihre Anweisungen werden, abh√§ngig von der Anzahl der Leben, die Lebens-Kreise ausgef√ºllt üî¥ oder als leerer Rahmen ‚ö™Ô∏è gezeichnet.
     - Die Methode `gameArea::changePlayerStyle()` regelt die richtige Setzung des `playerStyle`. Anhand der Anzahl der Leben wird in ihr mit dem entsprechenen Style-Wert von 0, 1 oder 2 die `player::setPlayerStyle()`-Methode aufgerufen, um die Darstellung des Spielers zu ver√§ndern und ihn bei Lebensverlust abgeschw√§cht darzustellen. 
    - Die Methode `gameArea::drawEnemies()` bekommt ebenfalls den `painter` √ºbergeben. Diese Methode ist f√ºr die Abbildung der Gegnerelemente des Vektors `std::vector<element*> enemies` anhand des `element::elementType` im Spielfeld zust√§ndig und enth√§lt auch die Kollisionsabfrage zwischen Spieler und Gegnern. Innerhalb einer `for`-Schleife werden mithilfe eines auf der `class element` basierenden Pointer-Objekts f√ºr jedes Vektorelement die optische Darstellung (QBrush: QColor, Qt::BrushStyle, QPen) festgelegt. In einem `switch`-case √ºber den `elementType` der Vektorbestandteile wird die Zeichnung der Form dem jeweiligen Gegnerelement zugeordnet. Au√üerdem wird die Methode `element::moveElement()` aufgerufen, um alle Elemente mit ihrer individuellen Fallgeschwindigkeit (`element::yMovement`) im Spiel zu bewegen. 
    - F√ºr die Kollisionsabfrage in der Methode `gameArea::drawEnemies()` wird die Methode `intersects()` der QT-Klasse `QRectF`genutzt. Um diese nutzen zu k√∂nnen, wurde innerhalb der Methode ein neues Rechteck f√ºr den Spieler definiert, auf das die aktuelle Spielerposition √ºbertragen wird. Durch eine `if`-Bedingung, mit der √ºberpr√ºft wird, ob sich der Spieler mit einem Gegnerelement schneidet, w√§hrend er verwundbar ist, werden die Zust√§nde `unverwundbar` und `getroffen` und damit auch ihre Timer/Timeouts ausgel√∂st und das Spiel durch den Aufruf der `gameArea::setRunning()`-Methode in den inaktiven Zustand versetzt. Durch eine weitere `if`-Bedingung wird √ºberpr√ºft, ob es sich bei dem vom Spieler ber√ºhrten Element um einen roten Kreis üî¥ handelt, da dann Leben hinzugef√ºgt werden sollen; vorausgesetzt die Leben sind nicht voll aufgeladen. In jedem anderen Fall, also bei Schneiden des Spielers mit jedem anderen Gegnerelement, wird ihm ein Leben abgezogen. Die Ver√§nderung der optischen Darstellung des Spielers wird in beiden Fallen durch den Aufruf der Methode `gameArea::changePlayerStyle()` realisiert. So wurde implementiert, dass der Spieler bei Lebensverlust in zwei Abstufungen abgeschw√§cht dargestellt wird, sich seine Darstellung aber auch wieder verbessert, wenn er ein herunterfallendes Lebenelement üî¥ ber√ºhrt und ein Leben wiederhergestellt wird. Innerhalb der `for`-Schleife wird au√üerdem durch eine weitere `if`-Bedingung implementiert, dass f√ºr jedes Gegner-Element, dass den unteren Spielfeldrand uberschreitet, ein neuer zuf√§lliger Gegner erzeugt werden soll. 
    - In der Methode `gameArea::gameIsOver()` wird die Game Over-Anzeige am Spielende konfiguriert. Sie legt die Texte und ihre Position sowie Schriftart und Schriftgr√∂√üe fest, setzt die Spielpunkte zur√ºck und l√∂scht alle vorhandenen Gegner, indem sie durch Aufruf der `element::newElement`-Methode neue zuf√§llige Gegner au√üerhalb des sichtbaren Spielbereichs erzeugt. Die Zur√ºcksetzung der Lebensanzeige und der Spielerdarstellung wurde bewusst in die bereits beschriebene Methode `gameArea::updateGame` ausgelagert, um den anf√§nglichen Spielstand erst wiederherzustellen, wenn die Game Over-Pause vorbei ist. 
    - Die Methode `gameArea::setRunning()` bekommt den aktuellen Spielstatus (`running`:`true` oder `false`) √ºbergeben und ver√§ndert anhand dessen die Farbe des Spielhintergrundes, um einen optischen Unterschied zwischen inaktivem und aktivem Spiel zu erzeugen.
    - Die Methode `gameArea::serialize()` legt die Aktion f√ºr die `gameWidget::saveGame()`-Methode fest und ist f√ºr die Speicherung des aktuellen Spielstandes zust√§ndig. In ihr werden **chronologisch** die zu speichernden Spielinformationen in ein QFile-Objekt und damit in die Speicherungsdatei exportiert: 
        - Spieler: aktuelle X-Position (`playerX`), aktueller Stil (`playerStyle`), 
        - f√ºr jedes Gegnerelement: Y- und X-Position und `elementType`
        - die Anzahl der Punkte und die Anzahl der Leben
    - Die Methode `gameArea::deserialize()` liest die gespeicherten Informationen aus der Datei. Dazu wird ein Objekt der Klasse `QString` genutzt, um die Daten Zeile f√ºr Zeile auslesen zu k√∂nnen. F√ºr die Verarbeitung der durch Komma getrennten Auflistung wird eine `QStringList` genutzt, da die Informationen eines Gegnerelements bei der Speicherung jeweils durch Kommas getrennt wurden. Da die Spielinformationen √ºber `QString/QStringList` als Zeilen verwaltet werden, m√ºssen sie wieder in numerische Werte umgewandelt werden. Mithilfe der in den Klassen `player` und `element` implementierten set-Methoden sowie der Setzung der `int`-Variablen `gamePoints` und `leben` kann der aktuelle Spielstand durch die gespeicherten Werte ersetzt werden. Durch den Aufruf der `QWidget`-Methode `update` werden diese dann auf das aktuelle Spiel angewendet und der gespeicherte Spielzustand wiederhergestellt.
    - Hinweis: Beim Laden eines gespeicherten Spielzustandes zeigt der QT Creator folgende Ausgabe der Anwendung an: '*objc[901]: Class FIFinderSyncExtensionHost is implemented in both /System/Library/PrivateFrameworks/FinderKit.framework/Versions/A/FinderKit (0x7fff8fd3ac90) and /System/Library/PrivateFrameworks/FileProvider.framework/OverrideBundles/FinderSyncCollaborationFileProviderOverride.bundle/Contents/MacOS/FinderSyncCollaborationFileProviderOverride (0x1182fdcd8). One of the two will be used. Which one is undefined.*'
    Der Grund f√ºr diese Meldung konnte trotz Internetrecherche nicht vollst√§ndig ermittelt werden. Eventuell h√§ngt das Problem mit dem Mac-Betriebssystem OSX High Sierra zusammen, da das Problem nur auf Mac-Ger√§ten, aber nicht auf Windows-PCs auftritt. Siehe: https://github.com/jarvisteach/appJar/issues/285, https://stackoverflow.com/questions/46999695/class-fifindersyncextensionhost-is-implemented-in-both-warning-in-xcode-si. Die Meldung beeintr√§chtigt die Funktionalit√§t des Programms jedoch in keinster Weise. Das Laden des gespeicherten Spielzustandes ist trotz der Meldung mit allen Informationen einwandfrei m√∂glich.
