# SS18-Semesterarbeit-CPP2-Roland
Semesterarbeit von Kim Roland im BM3-Modul Softwaretechnologie, Seminar "Objektorientierte Programmierung: C++-Programmieren-2"

# Dokumentation
Im Rahmen dieser Semesterarbeit wurden die Stufen I, II und III der Aufgabenstellung erfolgreich realisiert.

### Projekt herunterladen
- Projekt-Masterversion aus diesem Repository als ZIP-Ordner herunterladen und entpacken
- .pro-Datei des Projektes (*SS18-Semesterarbeit-CPP2-Roland.pro*) mit QT √∂ffnen und konfigurieren
- Ausf√ºhren (Kompilieren erfolgreich getestet mit folgenden Programmversionen: *Qt 5.9.2 (Clang 7.0 (Apple), 64 bit)* und *Qt Creator 4.4.1*)
- Spielwidget √∂ffnet sich

### Spielfunktionen

#### Spiel starten
Durch Anklicken des **Start**-Buttons in der oben linken Ecke des Spielfensters wird das Spiel gestartet. Der Button wechselt die Beschriftung zu **Pause**. √úber erneutes Anklicken des Buttons kann das Spiel pausiert werden.

#### Spielen
Der Spieler (schraffiertes Rechteck) kann sich mit den Tastatur-Pfeiltasten ‚¨ÖÔ∏è ‚û°Ô∏è am unteren Rand des Spielfeldes nach links und rechts bewegen und muss den herunterfallenden Elementen (Gegnern) ausweichen. Wird der Spieler von einem Gegnerelement getroffen (die beiden Spielobjekte ber√ºhren sich), verliert der Spieler ein Leben (‚ö™Ô∏èüî¥üî¥: Lebensanzeige in der oberen rechten Spielfeldecke) und das Spiel friert kurz ein. Nach dieser kurzen Spielpause startet das Spiel wieder und l√§uft weiter. Wenn der Spieler getroffen wurde, wird er abgeschw√§cht dargestellt, je nach Anzahl der noch vorhandenen Leben. Insgesamt gibt es drei verschiedene optische Darstellungen des Spielers (bei vollen Leben, bei Verlust eines Lebens, bei nur noch einem vorhandenen Leben). Au√üerdem ist der Spieler nach der Kollision mit einem Gegnerelement f√ºr ein paar Sekunden unverwundbar (zugunsten des besseren Spielflusses, um eine direkt darauffolgende Kollision mit einem anderen Gegnerelement zu vermeiden). Danach kann er wieder von weiteren Gegnerelementen getroffen werden.
Verlorene Leben k√∂nnen durch die Ber√ºhrung von herunterfallenden roten Kreis-Elementen üî¥, die optisch dem Aussehen der Lebensanzeige entsprechen, regeneriert werden. Bei der Kollision mit dieser Art von Elementen wird das Spiel ebenfalls kurz eingefroren, aber ein Leben hinzugef√ºgt statt abgezogen. Die maximale Anzahl an Leben entspricht 3, bei voller Lebensanzahl k√∂nnen die Leben nicht weiter addiert werden.

#### Speichern und Laden
Die Buttons **Speichern** und **Laden** erm√∂glichen es dem Spieler, den aktuellen Spielstand f√ºr das Weiterspielen zu einem sp√§teren Zeitpunkt zu speichern oder einen alten gespeicherten Spielstand wiederherzustellen. Um diese Funktionen nutzen zu k√∂nnen, darf das Spiel nicht laufen, sondern muss pausiert sein. 
Im Rahmen der Speicherung lassen sich alle relevanten Spielinformationen speichern: die aktuelle Position des Spielers sowie seine aktuelle optische Darstellung, die Anzahl seiner vorhandenen Leben, die bisher erreichte Punktzahl sowie die Position und der jeweilige Element-Typ (Form, Farbe und Fallgeschwindkeit) der sich momentan im Spielfeld befindenden Gegnerelemente.
Ein alter Spielstand kann sowohl direkt nach dem Start der Spielanwendung als auch nach dem Pausieren eines bereits gelaufenen Spiels geladen werden. Im Rahmen des Ladens werden die beschriebenen Spielinformationen vollst√§ndig wiederhergestellt und der Spieler kann durch Anklicken des **Start**-Buttons mit dem geladenen Spielstand weiterspielen.

#### Spielende
Hat der Spieler alle drei Leben verloren, wird das Spielende durch die Anzeige von "Game Over" und der in dem Spieldurchgang erreichten Punktzahl angezeigt. Die Spielinformationen werden zur√ºckgesetzt (optische Spielerdarstellung, Lebensanzahl und Punktzahl), die aktuellen Gegner entfernt/neu erzeugt und das Spiel startet erneut. Alternativ kann die gesamte Spielanwendung auch √ºber den Button **Ende** am unteren linken Spielfeldrand beendet werden.

## Programm-Erl√§uterungen: Wichtige Klassen und Methoden
1. Die `class gameWidget` erstellt das Spielfenster und definiert dessen Aufbau, die Funktions-Buttons (**Start/Pause**, **Speichern**, **Laden**, **Ende**), deren verkn√ºpfte Methoden und intialisiert den Renderbereich f√ºr das Zeichenfeld, in dem das Spiel stattfindet, als `myGameArea` auf Basis der `class gameArea`.
    - `gameWidget::startStopGame()`: regelt aktiven und inaktiven Zustand des Spiels, ver√§ndert die Beschriftung des **Start**/**Pause**-Button, setzt aktiven und inaktiven Zustand der Buttons **Speichern** und **Laden** anhand des Spielstatus.
    - `gameWidget::saveGame()`: l√∂st Erzeugung der Datei f√ºr die Speicherung aus, ruft Methode `gameArea::serialize()`auf.
    - `gameWidget::loadGame()`: l√∂st Lesen der Datei f√ºr das Laden aus, ruft Methode `gameArea::deserialize()`auf.

2. Die `class player` ist f√ºr die Definition des Spielerrechtecks zust√§ndig und beinhaltet die n√∂tigen Methoden zur Erzeugung und Bewegung des Spieleravatars:
    - Setter- und Getter-Methoden f√ºr die Positionsfestlegung (`playerX`, `playerY`) und Abmessungen (`playerWidth`, `playerHeight`) des Spielers, f√ºr die Schrittweite der Spielerbewegung (`playerMove`) sowie f√ºr die ver√§nderte optische Darstellung (Farbe und F√ºllmuster) des Spielers bei Lebensverlust (`playerColor`, `playerPattern`). F√ºr letzteres enth√§lt die Klasse au√üerdem eine Set- und Get-Methode zur Verwaltung der ver√§nderten Spielerdarstellung (`playerStyle`), anhand von drei numerischen Werten (0,1,2)
      - `playerStyle==0`: 'gesunde' Darstellung des Spielers bei vollen Leben, vollblaues schraffiertes Quadrat
      - `playerStyle==1`: abgeschw√§chte Darstellung des Spielers Stufe 1: mittelblau und gepunktet
      - `playerStyle==2`: abgeschw√§chte Darstellung des Spielers Stufe 2: helles Blau, leerer Rahmen
    - `paintEvent` und `keyPressEvent` zur Zeichnung und Bewegungsf√§higkeit des Spielers in der `gameArea`
    - Die `class movement` dient als Hilfsklasse f√ºr die `class player`, verwaltet die Bewegungen des Spielers √ºber ein enum, um dieses in der `player::movePlayer()`-Methode verwenden zu k√∂nnen und initalisiert die Methode dynamisch mit dem enum und einem Ausgangswert

3. Die `class element` ist f√ºr die Definition und Erzeugung der Gegnerelemente (*enemies*) im Spiel zust√§ndig:
    - Die Variable `elementType` √ºbernimmt dabei eine zentrale Rolle, da √ºber sie ein numerischer Wert von 0-5 gespeichert wird, der jeweils f√ºr ein bestimmtes Gegnerelement steht. Mit diesem Wert wird die Definition der spezifischen Elementeigenschaften in der Methode `element::setElement()` verkn√ºpft.
    - Die Methode `element::newElement()` sorgt f√ºr die zuf√§llige Auswahl neuer Gegnerlemente, indem sie mit `rand()` zuf√§llige X-Positionen und zuf√§llige Werte des `elementType` generiert und mit diesen zuf√§lligen Werten die Methode `element::setElement()` aufruft. Au√üerdem definiert sie, dass das letzte Element der Gegnerliste (der rote Kreis, der Leben wieder hinzuf√ºgt) mit zehnprozentiger Wahrscheinlichkeit im Spiel auftreten werden soll. Die anderen neunzig Prozent des Gegneraufkommens werden zuf√§llig aus den 5 anderen Elementen zusammengestellt.
    - Die Methode `element::setElement()` enth√§lt Vektoren zur Speicherung der spezifischen Elementeigenschaften in Bezug auf die Gr√∂√üe/Abmessungen, die innere Farbe, die Farbe und Breite der Au√üenlinie, das F√ºllmuster und die Fallgeschwindigkeit eines Elements. Die Speicherung in den Vektoren erfolgt nach einer festen Reihenfolge, um Eigenschaften anhand ihrer Position im Vektor (ebenfalls 0-5) mit dem `elementType` zu verkn√ºpfen. Die Elementeigenschaften werden jeweils in einer Hilfsvariable pro Eigenschaft (`rect`,`color`,`pattern`,`pen`,`penWidth`,`yMovement`) gespeichert. Diese werden dynamisch verwendet und anhand des `elementType` ver√§ndert. Die Gegnerelemente des Spiels basieren alle auf der Klasse `QRectF`.
    - Die Methode `element::moveElement()` erzeugt das Fallen der Gegnerelemente, also ihre Bewegung im Spielfeld von oben nach unten, √ºber den Aufruf der `translate()`-Methode der Klasse `QRectF` mit dem elementspezifischen Vektorenwert `yMovement`.

4. Die `class gameArea` definiert das Zeichenfeld des Spiels, in dem sich der Spieler und die Gegnerelemente bewegen. Sie ist zust√§ndig f√ºr: den Spiel-Timer und die Punkteanzeige, die Aktualisierung, das Pausieren und das Ende des Spiels, f√ºr das Zeichnen der Gegner und der Leben, f√ºr die Kollisionsabfrage von Spieler und Gegnern sowie f√ºr das Ausl√∂sen der ver√§nderten Darstellung des Spielers bei seiner Kollision mit einem Gegnerelement. Kurz gesagt regelt die Klasse alles, was innerhalb des Spiels passiert. Die Klasse basiert auf der Qt-Klasse `QMainWindow`, um deren Framework zur Widgetgestaltung nutzen zu k√∂nnen. 
    - Im Konstruktor der `gameArea` wird der Anfangszustand des Spiels initalisiert. Auf Basis der Positions- und Layout-Definitionen und -Methoden der `class player` wird das Spielerrechteck im Zeichenfeld erzeugt (`gamePlayer`). Die Methode `gameArea::setRunning()` sowie ihre `bool`-Variable `running` werden auf `false` gesetzt, damit sich das Spielfenster mit inaktiven Spielzustand √∂ffnet. Desweiteren werden Anfangswerte f√ºr Spielpunkte, Leben und die f√ºr die verschiedenen Pause- und Endzust√§nde (`unverwundbar`, `getroffen` und `gameOver`) zust√§ndigen Variablen und Timer festgelegt. Au√üerdem wird hier der Spieltimer auf Basis der Klasse `QTimer` erzeugt und definiert sowie der Vektor `std::vector<element*> enemies`, √ºber den die Gegnerelemente in das Spiel implementiert werden, mit neuen zuf√§lligen Elementen bef√ºllt.
    - Die Methode `gameArea::updateGame()` regelt die Aktualisierung der Spielzust√§nde und des Punktecounters. Sie wurde im Konstruktor mit dem Timer verkn√ºpft. In ihr ist festgelegt, was w√§hrend der verschiedenen Spielphasen geschehen soll. W√§hrend das Spiel l√§uft, soll die Punktzahl konstant erh√∂ht werden. Au√üerdem werden hier die Zeitintervalle nach der Kollision mit einem Gegner und f√ºr die tempor√§re GameOver-Anzeige gestartet. Diese seperaten Zustands-Timer werden solange erh√∂ht, bis sie den Wert des zugeh√∂rigen Timeouts (in `gameArea.h` konstant festgelegt) erreicht haben. Es wird definiert, was nach dem jeweiligen Timeout geschehen soll: 
        - Wenn der Spieler getroffen wurde, wird das Spiel eingefroren, der Timer f√ºr das Timeout des `getroffen`-Zustandes gestartet und der Spieler `unverwundbar` gemacht (und damit auch der unverwundbar-Timer gestartet). Nach Ende des Timeouts wird das Spiel wieder in den aktiven Zustand versetzt, l√§uft also weiter. 
        - Wenn der Spieler `unverwundbar` ist, wird ebenfalls ein Timer f√ºr die Zeit der Unverwundbarkeit gestartet. So wird verhindert, dass der Spieler erneut mit dem gleichen, ebenfalls eingefrorenen Gegner kollidiert (da die beiden sich immer noch ber√ºhren), ohne die Chance zu haben, auszuweichen. Nach Ende des `unverwundbar`-Zustands kann der Spieler wieder von Gegnern getroffen werden. 
        - Wenn der Spieler das letzte Leben verliert, wird in der Methode `gameArea::drawEnemies()` durch den Aufruf der `gameArea::gameIsOver()`-Methode die bool-Variable `gameOver`auf true gesetzt (und `getroffen` auf `false`, um nicht den `getroffenTimer`auszul√∂sen). Dadurch endet das Spiel ein, die Game Over-Anzeige erscheint und der gameOver-Timer wird gestartet. Nach dem Ende des gameOver-Timeouts wird die Game Over-Anzeige wieder vom Spielfeld entfernt sowie die Leben und die Spielerdarstellung zur√ºckgesetzt.
    - Das `gameArea::paintEvent()` l√∂st die `drawLives()`- und `drawEnemies()`-Methoden aus und √ºbergibt diesen jeweils den im paintEvent erzeugten `painter`.
    - Die Methode `gameArea::drawLives()` ist f√ºr die Lebensanzeige zust√§ndig. Durch ihre Anweisungen werden, abh√§ngig von der Anzahl der Leben, die Lebens-Kreise ausgef√ºllt üî¥ oder als leerer Rahmen ‚ö™Ô∏è gezeichnet.
     - Die Methode `gameArea::changePlayerStyle()` regelt die richtige Setzung des `playerStyle`. Anhand der Anzahl der Leben wird in ihr mit dem entsprechenen Style-Wert von 0, 1 oder 2 die `player::setPlayerStyle()`-Methode aufgerufen, um die Darstellung des Spielers zu ver√§ndern, ihn bei Lebensverlust abgeschw√§cht darzustellen und seine Darstellung bei Ber√ºhrung eines Leben-Elements üî¥ wieder zu verbessern. 
    - Die Methode `gameArea::drawEnemies()` ist f√ºr die Abbildung der Gegnerelemente des Vektors `std::vector<element*> enemies` anhand des `elementType` im Spielfeld zust√§ndig und enth√§lt auch die Kollisionsabfrage zwischen Spieler und Gegnern. Innerhalb einer `for`-Schleife wird mithilfe eines auf der `class element` basierenden Pointer-Objekts f√ºr jedes Vektorelement die optische Darstellung (QBrush: QColor, Qt::BrushStyle; QPen) festgelegt. In einem `switch`-case √ºber den `elementType` wird die Zeichnung der Form dem jeweiligen Gegnerelement zugeordnet. Au√üerdem wird die Methode `element::moveElement()` aufgerufen, um alle Elemente mit ihrer individuellen Fallgeschwindigkeit (`yMovement`) im Spiel zu bewegen. Auch diese Zuweisung erfolgt √ºber den `elementType`.
    - F√ºr die Kollisionsabfrage in der Methode `gameArea::drawEnemies()` wird die Methode `intersects()` der QT-Klasse `QRectF` genutzt. Um die Methode verwenden zu k√∂nnen, wurden innerhalb der Methode zwei Verwaltungsobjekte des Typs `QRectF` erzeugt (`player` und `enemy`), auf die jeweils die Spieler- bzw. Elementeigenschaften √ºbertragen werden. Vor der Kollisionsabfrage werden au√üerdem Breite und H√∂he des hellt√ºrkisen Dreiecks (pie) angepasst, da sich Spieler und Pie-Element ansonsten zu fr√ºh schneiden w√ºrden (durch `painter.drawPie()` wird vermutlich ein ganzer Kreis gezeichnet, von dem jedoch nur ein definiertes St√ºck sichtbar ist. Dadurch haben sich der Spieler und das Element bereits ber√ºhrt, bevor die Kollision f√ºr  sichtbar war. Dieses Problem wurde durch die Verkleinerung des Elements behoben und wirkt sich nicht auf die optische Darstellung des Dreiecks aus).
      Durch eine `if`-Bedingung, mit der √ºberpr√ºft wird, ob sich der Spieler mit einem Gegnerelement schneidet, w√§hrend er verwundbar ist, werden die Zust√§nde `unverwundbar`, `getroffen` oder `gameOver`und damit auch ihre Timer/Timeouts ausgel√∂st und das Spiel durch den Aufruf der `gameArea::setRunning()`-Methode in den inaktiven Zustand versetzt. Durch eine weitere `if`-Bedingung wird √ºberpr√ºft, ob es sich bei dem vom Spieler ber√ºhrten Element um einen roten Kreis üî¥ handelt, da dann Leben hinzugef√ºgt werden sollen; vorausgesetzt die Leben sind nicht voll aufgeladen. In jedem anderen Fall, also bei Schneiden des Spielers mit jedem anderen Gegnerelement, wird ihm ein Leben abgezogen. Die Ver√§nderung der optischen Darstellung des Spielers wird in beiden F√§llen durch den Aufruf der Methode `gameArea::changePlayerStyle()` realisiert. In dieser wird, abh√§ngig von der Anzahl der Leben, die `player::setPlayerStyle()`-Methode mit dem entsprechenden Wert von 0-2 f√ºr die Art der Darstellung aufgerufen. So wurde implementiert, dass der Spieler bei Lebensverlust in zwei Abstufungen abgeschw√§cht dargestellt wird, sich seine Darstellung aber auch wieder verbessert, wenn er ein herunterfallendes Lebenelement üî¥ ber√ºhrt und ein Leben wiederhergestellt wird. Innerhalb der `for`-Schleife wurde au√üerdem durch eine weitere `if`-Bedingung implementiert, dass jedes Gegner-Element, dass den unteren Spielfeldrand √ºberschreitet, durch einen neuen zuf√§lligen Gegner ersetzt werden soll. 
    - In der Methode `gameArea::gameIsOver()` wird die Game Over-Anzeige am Spielende konfiguriert. Sie legt die Texte sowie deren Position, Schriftart und Schriftgr√∂√üe fest, setzt die Spielpunkte zur√ºck und l√∂scht alle vorhandenen Gegner, indem sie durch Aufruf der `element::newElement()`-Methode neue zuf√§llige Gegner √ºberhalb des sichtbaren Spielbereichs erzeugt. Die Zur√ºcksetzung der Lebensanzeige und der Spielerdarstellung wurde bewusst in die bereits beschriebene Methode `gameArea::updateGame()` ausgelagert, um den anf√§nglichen Spielstand erst vollst√§ndig wiederherzustellen, wenn das Game Over-Timeout zuende ist. 
    - Die Methode `gameArea::setRunning()` bekommt den aktuellen Spielstatus (`running`:`true` oder `false`) √ºbergeben und ver√§ndert anhand dessen die Farbe des Spielhintergrundes, um einen optischen Unterschied zwischen inaktivem und aktivem Spiel zu erzeugen.
    - Die Methode `gameArea::serialize()` legt die Aktion f√ºr die `gameWidget::saveGame()`-Methode fest und ist f√ºr die Speicherung des aktuellen Spielstandes zust√§ndig. In ihr werden **chronologisch** die zu speichernden Spielinformationen mit einem QFile-Objekt in die Speicherungsdatei exportiert:
        - (√úberschrift; f√ºr Dateiabfrage beim Laden ben√∂tigt)
        - aktuelle X-Position des Spielers (`playerX`)
        - aktueller Stil (`playerStyle`)
        - Y-Position, X-Position, `elementType` (jedes Gegnerelements)
        - Anzahl der Punkte (`gamePoints`)
        - Anzahl der Leben (`leben`)
    - Die Methode `gameArea::deserialize()` legt die Aktion f√ºr die `gameWidget::loadGame()`-Methode fest und liest die gespeicherten Informationen aus der Datei. Dazu wird ein Objekt der Klasse `QString` genutzt, um die Daten Zeile f√ºr Zeile auslesen zu k√∂nnen. F√ºr die Verarbeitung der durch Komma getrennten Gegner-Eigenschaften wird eine `QStringList` genutzt. Da die Spielinformationen √ºber `QString/QStringList` als Zeilen verwaltet werden, m√ºssen sie wieder in numerische Werte umgewandelt werden. Mithilfe der in den Klassen `player` und `element` implementierten set-Methoden sowie der Zuweisung der `int`-Variablen `gamePoints` und `leben` kann der aktuelle Spielstand durch die gespeicherten Werte ersetzt werden. Durch den Aufruf der `QWidget`-Methode `update()` werden diese dann auf das aktuelle Spiel angewendet und der gespeicherte Spielzustand wiederhergestellt.
    - Hinweis: Beim Speichern bzw. Laden eines Spielzustandes zeigt der QT Creator folgende Ausgabe der Anwendung an: '*objc[901]: Class FIFinderSyncExtensionHost is implemented in both /System/Library/PrivateFrameworks/FinderKit.framework/Versions/A/FinderKit (0x7fff8fd3ac90) and /System/Library/PrivateFrameworks/FileProvider.framework/OverrideBundles/FinderSyncCollaborationFileProviderOverride.bundle/Contents/MacOS/FinderSyncCollaborationFileProviderOverride (0x1182fdcd8). One of the two will be used. Which one is undefined.*'
    Der Grund f√ºr diese Meldung konnte trotz Internetrecherche nicht vollst√§ndig ermittelt werden. Eventuell h√§ngt das Problem mit dem Mac-Betriebssystem OSX High Sierra zusammen, da das Problem nur auf Mac-Ger√§ten, aber nicht auf Windows-PCs auftritt (siehe: https://github.com/jarvisteach/appJar/issues/285, https://stackoverflow.com/questions/46999695/class-fifindersyncextensionhost-is-implemented-in-both-warning-in-xcode-si). Die Meldung beeintr√§chtigt die Funktionalit√§t des Programms jedoch in keinster Weise. Das Speichern und Laden des Spielzustandes ist trotz der Meldung vollst√§ndig m√∂glich.
